package com.learn.core.multithreading.forkjoinpool.custom;

import java.util.List;
import java.util.Random;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.TimeUnit;

/**
 * Created by bid on 8/23/14.
 */
public class StudentRecursiveTask extends RecursiveTask<Student>
{

   public static void main(String[] args)
   {
      StudentRecursiveTask studentRecursiveTask = new StudentRecursiveTask();
      ForkJoinPool pool = new ForkJoinPool();
      pool.execute(studentRecursiveTask);


      do
      {
         System.out.printf("******************************************\n");
         System.out.printf("Main: Parallelism: %d\n", pool.getParallelism());
         System.out.printf("Main: Active Threads: %d\n", pool.getActiveThreadCount());
         System.out.printf("Main: Task Count: %d\n", pool.getQueuedTaskCount());
         System.out.printf("Main: Steal Count: %d\n", pool.getStealCount());
         System.out.printf("******************************************\n");
         try
         {
            TimeUnit.SECONDS.sleep(1);
         } catch (InterruptedException e)
         {
            e.printStackTrace();
         }
      } while ((!studentRecursiveTask.isDone()));
      //Shut down ForkJoinPool using the shutdown() method.
      pool.shutdown();
      //Write the number of results generated by each task to the console.
      Student results;
      results = studentRecursiveTask.join();
      System.out.printf("System: %s files found.\n", results.getName());
      results = studentRecursiveTask.join();
      System.out.printf("Apps: %s files found.\n", results.getName());

   }


   @Override
   protected Student compute()
   {
      Student studentElement = new Student();
      studentElement.setName("Dimon" + new Random().nextInt(5));

      return studentElement;
   }
}
