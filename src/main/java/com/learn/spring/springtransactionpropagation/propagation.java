package com.learn.spring.springtransactionpropagation;

import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * Created with IntelliJ IDEA.
 * User: Buh
 * Date: 18.08.12
 * Time: 12:03
 * To change this template use File | Settings | File Templates.
 */

// propagation - режим распространения транзакций
//При использовании ORM-фреймворка флаг read-only – это только подсказка для СУБД и директива для ORM-фреймворка (в данном случае Hibernate)
// установить режим NEVER очистки объектного кэша, указывающий, что кэш объектов не нужно синхронизировать с БД на протяжении этой единицы работы.
// Однако режим распространения REQUIRED все это переопределяет, позволяее транзакции начаться и рабтать так же, как в отсутствие флага read-only.
//Не забудьте: режим распространения по умолчанию для аннотации @Transactional - REQUIRED.
// Это значит, что транзакция начинается даже когда она на само деле не нужна.
// В зависимости от используемой СУБД это может стать причиной ненужных разделяемых блокировок, что может привести к взаимоблокировкам.
// Кроме того, бессмысленно тратятся процессорное время и ресурсы на запуск и окончание транзакции. Вывод: при использовании
// ORM-фреймворка флаг read-only тоже бесполезен и в большинстве случаев игнорируется. Но если вы настаиваете на его использовании,
// всегда устанавливайте режим распространения SUPPORTS, как показано в Листинге 9, при этом никакая транзакция не запускается.

    //Еще лучше вовсе избегать использования аннотации @Transactional при операциях чтения,

    //REQUIRED_NEW always creates new transaction.
    //We should use REQUIRED_NEW propagation only if we want to save result of the calling method regardless of the success of the operation.

    //Благодаря отсутствию автоматического отката для проверяемых транзакций вы можете перехватить это исключение и
    // выполнить какие-либо корректирующие действия (например, поместить сообщение в очередь на отправку) и сохранить остальную часть заказа.


//Платформа Java поддерживает три модели транзакций:
//        Модель локальных транзакций.
//        Модель программных транзакций.
//        Модель декларативных транзакций.

//    Модель локальных транзакций заключается в том, что транзакциями управляет нижний уровень базы данных. Мы управляем только подключением.
//Модель программных транзакций позволяет нам самим управлять началом транзакций, фиксацией, откатом.
//В Spring Framework есть два способа реализации модели программных транзакций. Один способ – через Spring TransactionTemplate,
//другой – с использованием менеджера транзакций Spring напрямую.

//Модель декларативных транзакций, известная также как Container Managed Transactions (CMT, транзакции,
// управляемые контейнером) – это наиболее распространенная транзакционная модель на платформе Java.
// В этой модели среда контейнера заботится о запуске, фиксации и окате транзакций.
// Разработчик отвечает только за указание поведения транзакции. Большинство проблем с транзакциями,
// обсуждавшихся в первой части статьи, относятся именно к модели декларативных транзакций.

    //Платформа Java поддерживает шесть типов транзакционных атрибутов, независимо от того, используете вы EJB или Spring Framework:
//        Required
        // Если транзакция существовала, то будет использован ее контекст, если не существовала, то будет создана новая транзакция.
//        Mandatory
        // Если транзакция существовала уже, то будет использован ее контекст, если нет, то будет сгенерировано исключение
//        RequiresNew
        // Метод, помеченный этой транзакцией, всегда будет создавать новую транзакцию. Имеет смысл использовать эту аннотацию, если не важен успен операции,
//    если в любом случае нужно отобразить саму попытку операции
//        Supports
//      Если транзакция была, то испльзуется, если нет, то метод выполняется без транзакции.
//        NotSupported
//      Если транзакция была, то она приостанавливается до конца выполнения метода, если нет, то метод выполняется.
//        Never
//        Если транзакции нет, то выполняется метод, если была, то генерируется исключение
//

//    Транцакционные стратегии:
//    - Клиент-ориентированнная - клиент сам заботиться о многих операциях из цепочки из интерфейса
//    - Api Layer стратегия - в одном методе описана вся цепочка транзакции, учтены все возможные варианты
//    - Стратегия высокого параллелизма - для приложений, неспособных поддерживать длительные (бизнес) транзакции. Максимально избавляет приложение от охвата транзакциями
//    - Статегия высокой работоспособности.

public class propagation {
    public static void main(String[] args){

    }

    @Transactional(readOnly = true, propagation = Propagation.REQUIRED)
    public void transactionAction(){

    }
}
